<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>manimlib.scene.scene API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>manimlib.scene.scene</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import inspect
import random
import warnings
import platform

from tqdm import tqdm as ProgressDisplay
import numpy as np

from manimlib.animation.animation import Animation
from manimlib.animation.creation import Write
from manimlib.animation.transform import MoveToTarget, ApplyMethod
from manimlib.camera.camera import Camera
from manimlib.constants import *
from manimlib.container.container import Container
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.svg.tex_mobject import TextMobject
from manimlib.scene.scene_file_writer import SceneFileWriter
from manimlib.utils.iterables import list_update


class Scene(Container):
    CONFIG = {
        &#34;camera_class&#34;: Camera,
        &#34;camera_config&#34;: {},
        &#34;file_writer_config&#34;: {},
        &#34;skip_animations&#34;: False,
        &#34;always_update_mobjects&#34;: False,
        &#34;random_seed&#34;: 0,
        &#34;start_at_animation_number&#34;: None,
        &#34;end_at_animation_number&#34;: None,
        &#34;leave_progress_bars&#34;: False,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.camera = self.camera_class(**self.camera_config)
        self.file_writer = SceneFileWriter(
            self, **self.file_writer_config,
        )

        self.mobjects = []
        # TODO, remove need for foreground mobjects
        self.foreground_mobjects = []
        self.num_plays = 0
        self.time = 0
        self.original_skipping_status = self.skip_animations
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.setup()
        try:
            self.construct()
        except EndSceneEarlyException:
            pass
        self.tear_down()
        self.file_writer.finish()
        self.print_end_message()

    def setup(self):
        &#34;&#34;&#34;
        This is meant to be implement by any scenes which
        are comonly subclassed, and have some common setup
        involved before the construct method is called.
        &#34;&#34;&#34;
        pass

    def tear_down(self):
        pass

    def construct(self):
        pass  # To be implemented in subclasses

    def __str__(self):
        return self.__class__.__name__

    def print_end_message(self):
        print(&#34;Played {} animations&#34;.format(self.num_plays))

    def set_variables_as_attrs(self, *objects, **newly_named_objects):
        &#34;&#34;&#34;
        This method is slightly hacky, making it a little easier
        for certain methods (typically subroutines of construct)
        to share local variables.
        &#34;&#34;&#34;
        caller_locals = inspect.currentframe().f_back.f_locals
        for key, value in list(caller_locals.items()):
            for o in objects:
                if value is o:
                    setattr(self, key, value)
        for key, value in list(newly_named_objects.items()):
            setattr(self, key, value)
        return self

    def get_attrs(self, *keys):
        return [getattr(self, key) for key in keys]

    # Only these methods should touch the camera
    def set_camera(self, camera):
        self.camera = camera

    def get_frame(self):
        return np.array(self.camera.get_pixel_array())

    def get_image(self):
        return self.camera.get_image()

    def set_camera_pixel_array(self, pixel_array):
        self.camera.set_pixel_array(pixel_array)

    def set_camera_background(self, background):
        self.camera.set_background(background)

    def reset_camera(self):
        self.camera.reset()

    def capture_mobjects_in_camera(self, mobjects, **kwargs):
        self.camera.capture_mobjects(mobjects, **kwargs)

    def update_frame(
            self,
            mobjects=None,
            background=None,
            include_submobjects=True,
            ignore_skipping=True,
            **kwargs):
        if self.skip_animations and not ignore_skipping:
            return
        if mobjects is None:
            mobjects = list_update(
                self.mobjects,
                self.foreground_mobjects,
            )
        if background is not None:
            self.set_camera_pixel_array(background)
        else:
            self.reset_camera()

        kwargs[&#34;include_submobjects&#34;] = include_submobjects
        self.capture_mobjects_in_camera(mobjects, **kwargs)

    def freeze_background(self):
        self.update_frame()
        self.set_camera(Camera(self.get_frame()))
        self.clear()
    ###

    def update_mobjects(self, dt):
        for mobject in self.mobjects:
            mobject.update(dt)

    def should_update_mobjects(self):
        return self.always_update_mobjects or any([
            mob.has_time_based_updater()
            for mob in self.get_mobject_family_members()
        ])

    ###

    def get_time(self):
        return self.time

    def increment_time(self, d_time):
        self.time += d_time

    ###

    def get_top_level_mobjects(self):
        # Return only those which are not in the family
        # of another mobject from the scene
        mobjects = self.get_mobjects()
        families = [m.get_family() for m in mobjects]

        def is_top_level(mobject):
            num_families = sum([
                (mobject in family)
                for family in families
            ])
            return num_families == 1
        return list(filter(is_top_level, mobjects))

    def get_mobject_family_members(self):
        return self.camera.extract_mobject_family_members(self.mobjects)

    def add(self, *mobjects):
        &#34;&#34;&#34;
        Mobjects will be displayed, from background to
        foreground in the order with which they are added.
        &#34;&#34;&#34;
        mobjects = [*mobjects, *self.foreground_mobjects]
        self.restructure_mobjects(to_remove=mobjects)
        self.mobjects += mobjects
        return self

    def add_mobjects_among(self, values):
        &#34;&#34;&#34;
        This is meant mostly for quick prototyping,
        e.g. to add all mobjects defined up to a point,
        call self.add_mobjects_among(locals().values())
        &#34;&#34;&#34;
        self.add(*filter(
            lambda m: isinstance(m, Mobject),
            values
        ))
        return self

    def remove(self, *mobjects):
        for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
            self.restructure_mobjects(mobjects, list_name, False)
        return self

    def restructure_mobjects(self, to_remove,
                             mobject_list_name=&#34;mobjects&#34;,
                             extract_families=True):
        &#34;&#34;&#34;
        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
        will be editing to contain other submobjects, but not m1, e.g. it will now
        insert m2 and m3 to where the group once was.
        &#34;&#34;&#34;
        if extract_families:
            to_remove = self.camera.extract_mobject_family_members(to_remove)
        _list = getattr(self, mobject_list_name)
        new_list = self.get_restructured_mobject_list(_list, to_remove)
        setattr(self, mobject_list_name, new_list)
        return self

    def get_restructured_mobject_list(self, mobjects, to_remove):
        new_mobjects = []

        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
            for mob in list_to_examine:
                if mob in set_to_remove:
                    continue
                intersect = set_to_remove.intersection(mob.get_family())
                if intersect:
                    add_safe_mobjects_from_list(mob.submobjects, intersect)
                else:
                    new_mobjects.append(mob)
        add_safe_mobjects_from_list(mobjects, set(to_remove))
        return new_mobjects

    # TODO, remove this, and calls to this
    def add_foreground_mobjects(self, *mobjects):
        self.foreground_mobjects = list_update(
            self.foreground_mobjects,
            mobjects
        )
        self.add(*mobjects)
        return self

    def add_foreground_mobject(self, mobject):
        return self.add_foreground_mobjects(mobject)

    def remove_foreground_mobjects(self, *to_remove):
        self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
        return self

    def remove_foreground_mobject(self, mobject):
        return self.remove_foreground_mobjects(mobject)

    def bring_to_front(self, *mobjects):
        self.add(*mobjects)
        return self

    def bring_to_back(self, *mobjects):
        self.remove(*mobjects)
        self.mobjects = list(mobjects) + self.mobjects
        return self

    def clear(self):
        self.mobjects = []
        self.foreground_mobjects = []
        return self

    def get_mobjects(self):
        return list(self.mobjects)

    def get_mobject_copies(self):
        return [m.copy() for m in self.mobjects]

    def get_moving_mobjects(self, *animations):
        # Go through mobjects from start to end, and
        # as soon as there&#39;s one that needs updating of
        # some kind per frame, return the list from that
        # point forward.
        animation_mobjects = [anim.mobject for anim in animations]
        mobjects = self.get_mobject_family_members()
        for i, mob in enumerate(mobjects):
            update_possibilities = [
                mob in animation_mobjects,
                len(mob.get_family_updaters()) &gt; 0,
                mob in self.foreground_mobjects
            ]
            if any(update_possibilities):
                return mobjects[i:]
        return []

    def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
        if self.skip_animations and not override_skip_animations:
            times = [run_time]
        else:
            step = 1 / self.camera.frame_rate
            times = np.arange(0, run_time, step)
        time_progression = ProgressDisplay(
            times, total=n_iterations,
            leave=self.leave_progress_bars,
            ascii=False if platform.system() != &#39;Windows&#39; else True
        )
        return time_progression

    def get_run_time(self, animations):
        return np.max([animation.run_time for animation in animations])

    def get_animation_time_progression(self, animations):
        run_time = self.get_run_time(animations)
        time_progression = self.get_time_progression(run_time)
        time_progression.set_description(&#34;&#34;.join([
            &#34;Animation {}: &#34;.format(self.num_plays),
            str(animations[0]),
            (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
        ]))
        return time_progression

    def compile_play_args_to_animation_list(self, *args, **kwargs):
        &#34;&#34;&#34;
        Each arg can either be an animation, or a mobject method
        followed by that methods arguments (and potentially follow
        by a dict of kwargs for that method).
        This animation list is built by going through the args list,
        and each animation is simply added, but when a mobject method
        s hit, a MoveToTarget animation is built using the args that
        follow up until either another animation is hit, another method
        is hit, or the args list runs out.
        &#34;&#34;&#34;
        animations = []
        state = {
            &#34;curr_method&#34;: None,
            &#34;last_method&#34;: None,
            &#34;method_args&#34;: [],
        }

        def compile_method(state):
            if state[&#34;curr_method&#34;] is None:
                return
            mobject = state[&#34;curr_method&#34;].__self__
            if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
                animations.pop()
                # method should already have target then.
            else:
                mobject.generate_target()
            #
            if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
                method_kwargs = state[&#34;method_args&#34;].pop()
            else:
                method_kwargs = {}
            state[&#34;curr_method&#34;].__func__(
                mobject.target,
                *state[&#34;method_args&#34;],
                **method_kwargs
            )
            animations.append(MoveToTarget(mobject))
            state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
            state[&#34;curr_method&#34;] = None
            state[&#34;method_args&#34;] = []

        for arg in args:
            if isinstance(arg, Animation):
                compile_method(state)
                animations.append(arg)
            elif inspect.ismethod(arg):
                compile_method(state)
                state[&#34;curr_method&#34;] = arg
            elif state[&#34;curr_method&#34;] is not None:
                state[&#34;method_args&#34;].append(arg)
            elif isinstance(arg, Mobject):
                raise Exception(&#34;&#34;&#34;
                    I think you may have invoked a method
                    you meant to pass in as a Scene.play argument
                &#34;&#34;&#34;)
            else:
                raise Exception(&#34;Invalid play arguments&#34;)
        compile_method(state)

        for animation in animations:
            # This is where kwargs to play like run_time and rate_func
            # get applied to all animations
            animation.update_config(**kwargs)

        return animations

    def update_skipping_status(self):
        if self.start_at_animation_number:
            if self.num_plays == self.start_at_animation_number:
                self.skip_animations = False
        if self.end_at_animation_number:
            if self.num_plays &gt;= self.end_at_animation_number:
                self.skip_animations = True
                raise EndSceneEarlyException()

    def handle_play_like_call(func):
        def wrapper(self, *args, **kwargs):
            self.update_skipping_status()
            allow_write = not self.skip_animations
            self.file_writer.begin_animation(allow_write)
            func(self, *args, **kwargs)
            self.file_writer.end_animation(allow_write)
            self.num_plays += 1
        return wrapper

    def begin_animations(self, animations):
        curr_mobjects = self.get_mobject_family_members()
        for animation in animations:
            # Begin animation
            animation.begin()
            # Anything animated that&#39;s not already in the
            # scene gets added to the scene
            mob = animation.mobject
            if mob not in curr_mobjects:
                self.add(mob)
                curr_mobjects += mob.get_family()

    def progress_through_animations(self, animations):
        # Paint all non-moving objects onto the screen, so they don&#39;t
        # have to be rendered every frame
        moving_mobjects = self.get_moving_mobjects(*animations)
        self.update_frame(excluded_mobjects=moving_mobjects)
        static_image = self.get_frame()
        last_t = 0
        for t in self.get_animation_time_progression(animations):
            dt = t - last_t
            last_t = t
            for animation in animations:
                animation.update_mobjects(dt)
                alpha = t / animation.run_time
                animation.interpolate(alpha)
            self.update_mobjects(dt)
            self.update_frame(moving_mobjects, static_image)
            self.add_frames(self.get_frame())

    def finish_animations(self, animations):
        for animation in animations:
            animation.finish()
            animation.clean_up_from_scene(self)
        self.mobjects_from_last_animation = [
            anim.mobject for anim in animations
        ]
        if self.skip_animations:
            # TODO, run this call in for each animation?
            self.update_mobjects(self.get_run_time(animations))
        else:
            self.update_mobjects(0)

    @handle_play_like_call
    def play(self, *args, **kwargs):
        if len(args) == 0:
            warnings.warn(&#34;Called Scene.play with no animations&#34;)
            return
        animations = self.compile_play_args_to_animation_list(
            *args, **kwargs
        )
        self.begin_animations(animations)
        self.progress_through_animations(animations)
        self.finish_animations(animations)

    def idle_stream(self):
        self.file_writer.idle_stream()

    def clean_up_animations(self, *animations):
        for animation in animations:
            animation.clean_up_from_scene(self)
        return self

    def get_mobjects_from_last_animation(self):
        if hasattr(self, &#34;mobjects_from_last_animation&#34;):
            return self.mobjects_from_last_animation
        return []

    def get_wait_time_progression(self, duration, stop_condition):
        if stop_condition is not None:
            time_progression = self.get_time_progression(
                duration,
                n_iterations=-1,  # So it doesn&#39;t show % progress
                override_skip_animations=True
            )
            time_progression.set_description(
                &#34;Waiting for {}&#34;.format(stop_condition.__name__)
            )
        else:
            time_progression = self.get_time_progression(duration)
            time_progression.set_description(
                &#34;Waiting {}&#34;.format(self.num_plays)
            )
        return time_progression

    @handle_play_like_call
    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):
        self.update_mobjects(dt=0)  # Any problems with this?
        if self.should_update_mobjects():
            time_progression = self.get_wait_time_progression(duration, stop_condition)
            # TODO, be smart about setting a static image
            # the same way Scene.play does
            last_t = 0
            for t in time_progression:
                dt = t - last_t
                last_t = t
                self.update_mobjects(dt)
                self.update_frame()
                self.add_frames(self.get_frame())
                if stop_condition is not None and stop_condition():
                    time_progression.close()
                    break
        elif self.skip_animations:
            # Do nothing
            return self
        else:
            self.update_frame()
            dt = 1 / self.camera.frame_rate
            n_frames = int(duration / dt)
            frame = self.get_frame()
            self.add_frames(*[frame] * n_frames)
        return self

    def wait_until(self, stop_condition, max_time=60):
        self.wait(max_time, stop_condition=stop_condition)

    def force_skipping(self):
        self.original_skipping_status = self.skip_animations
        self.skip_animations = True
        return self

    def revert_to_original_skipping_status(self):
        if hasattr(self, &#34;original_skipping_status&#34;):
            self.skip_animations = self.original_skipping_status
        return self

    def add_frames(self, *frames):
        dt = 1 / self.camera.frame_rate
        self.increment_time(len(frames) * dt)
        if self.skip_animations:
            return
        for frame in frames:
            self.file_writer.write_frame(frame)

    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
        if self.skip_animations:
            return
        time = self.get_time() + time_offset
        self.file_writer.add_sound(sound_file, time, gain, **kwargs)

    def show_frame(self):
        self.update_frame(ignore_skipping=True)
        self.get_image().show()


class EndSceneEarlyException(Exception):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="manimlib.scene.scene.EndSceneEarlyException"><code class="flex name class">
<span>class <span class="ident">EndSceneEarlyException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EndSceneEarlyException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="manimlib.scene.scene.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene(Container):
    CONFIG = {
        &#34;camera_class&#34;: Camera,
        &#34;camera_config&#34;: {},
        &#34;file_writer_config&#34;: {},
        &#34;skip_animations&#34;: False,
        &#34;always_update_mobjects&#34;: False,
        &#34;random_seed&#34;: 0,
        &#34;start_at_animation_number&#34;: None,
        &#34;end_at_animation_number&#34;: None,
        &#34;leave_progress_bars&#34;: False,
    }

    def __init__(self, **kwargs):
        Container.__init__(self, **kwargs)
        self.camera = self.camera_class(**self.camera_config)
        self.file_writer = SceneFileWriter(
            self, **self.file_writer_config,
        )

        self.mobjects = []
        # TODO, remove need for foreground mobjects
        self.foreground_mobjects = []
        self.num_plays = 0
        self.time = 0
        self.original_skipping_status = self.skip_animations
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.setup()
        try:
            self.construct()
        except EndSceneEarlyException:
            pass
        self.tear_down()
        self.file_writer.finish()
        self.print_end_message()

    def setup(self):
        &#34;&#34;&#34;
        This is meant to be implement by any scenes which
        are comonly subclassed, and have some common setup
        involved before the construct method is called.
        &#34;&#34;&#34;
        pass

    def tear_down(self):
        pass

    def construct(self):
        pass  # To be implemented in subclasses

    def __str__(self):
        return self.__class__.__name__

    def print_end_message(self):
        print(&#34;Played {} animations&#34;.format(self.num_plays))

    def set_variables_as_attrs(self, *objects, **newly_named_objects):
        &#34;&#34;&#34;
        This method is slightly hacky, making it a little easier
        for certain methods (typically subroutines of construct)
        to share local variables.
        &#34;&#34;&#34;
        caller_locals = inspect.currentframe().f_back.f_locals
        for key, value in list(caller_locals.items()):
            for o in objects:
                if value is o:
                    setattr(self, key, value)
        for key, value in list(newly_named_objects.items()):
            setattr(self, key, value)
        return self

    def get_attrs(self, *keys):
        return [getattr(self, key) for key in keys]

    # Only these methods should touch the camera
    def set_camera(self, camera):
        self.camera = camera

    def get_frame(self):
        return np.array(self.camera.get_pixel_array())

    def get_image(self):
        return self.camera.get_image()

    def set_camera_pixel_array(self, pixel_array):
        self.camera.set_pixel_array(pixel_array)

    def set_camera_background(self, background):
        self.camera.set_background(background)

    def reset_camera(self):
        self.camera.reset()

    def capture_mobjects_in_camera(self, mobjects, **kwargs):
        self.camera.capture_mobjects(mobjects, **kwargs)

    def update_frame(
            self,
            mobjects=None,
            background=None,
            include_submobjects=True,
            ignore_skipping=True,
            **kwargs):
        if self.skip_animations and not ignore_skipping:
            return
        if mobjects is None:
            mobjects = list_update(
                self.mobjects,
                self.foreground_mobjects,
            )
        if background is not None:
            self.set_camera_pixel_array(background)
        else:
            self.reset_camera()

        kwargs[&#34;include_submobjects&#34;] = include_submobjects
        self.capture_mobjects_in_camera(mobjects, **kwargs)

    def freeze_background(self):
        self.update_frame()
        self.set_camera(Camera(self.get_frame()))
        self.clear()
    ###

    def update_mobjects(self, dt):
        for mobject in self.mobjects:
            mobject.update(dt)

    def should_update_mobjects(self):
        return self.always_update_mobjects or any([
            mob.has_time_based_updater()
            for mob in self.get_mobject_family_members()
        ])

    ###

    def get_time(self):
        return self.time

    def increment_time(self, d_time):
        self.time += d_time

    ###

    def get_top_level_mobjects(self):
        # Return only those which are not in the family
        # of another mobject from the scene
        mobjects = self.get_mobjects()
        families = [m.get_family() for m in mobjects]

        def is_top_level(mobject):
            num_families = sum([
                (mobject in family)
                for family in families
            ])
            return num_families == 1
        return list(filter(is_top_level, mobjects))

    def get_mobject_family_members(self):
        return self.camera.extract_mobject_family_members(self.mobjects)

    def add(self, *mobjects):
        &#34;&#34;&#34;
        Mobjects will be displayed, from background to
        foreground in the order with which they are added.
        &#34;&#34;&#34;
        mobjects = [*mobjects, *self.foreground_mobjects]
        self.restructure_mobjects(to_remove=mobjects)
        self.mobjects += mobjects
        return self

    def add_mobjects_among(self, values):
        &#34;&#34;&#34;
        This is meant mostly for quick prototyping,
        e.g. to add all mobjects defined up to a point,
        call self.add_mobjects_among(locals().values())
        &#34;&#34;&#34;
        self.add(*filter(
            lambda m: isinstance(m, Mobject),
            values
        ))
        return self

    def remove(self, *mobjects):
        for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
            self.restructure_mobjects(mobjects, list_name, False)
        return self

    def restructure_mobjects(self, to_remove,
                             mobject_list_name=&#34;mobjects&#34;,
                             extract_families=True):
        &#34;&#34;&#34;
        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
        will be editing to contain other submobjects, but not m1, e.g. it will now
        insert m2 and m3 to where the group once was.
        &#34;&#34;&#34;
        if extract_families:
            to_remove = self.camera.extract_mobject_family_members(to_remove)
        _list = getattr(self, mobject_list_name)
        new_list = self.get_restructured_mobject_list(_list, to_remove)
        setattr(self, mobject_list_name, new_list)
        return self

    def get_restructured_mobject_list(self, mobjects, to_remove):
        new_mobjects = []

        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
            for mob in list_to_examine:
                if mob in set_to_remove:
                    continue
                intersect = set_to_remove.intersection(mob.get_family())
                if intersect:
                    add_safe_mobjects_from_list(mob.submobjects, intersect)
                else:
                    new_mobjects.append(mob)
        add_safe_mobjects_from_list(mobjects, set(to_remove))
        return new_mobjects

    # TODO, remove this, and calls to this
    def add_foreground_mobjects(self, *mobjects):
        self.foreground_mobjects = list_update(
            self.foreground_mobjects,
            mobjects
        )
        self.add(*mobjects)
        return self

    def add_foreground_mobject(self, mobject):
        return self.add_foreground_mobjects(mobject)

    def remove_foreground_mobjects(self, *to_remove):
        self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
        return self

    def remove_foreground_mobject(self, mobject):
        return self.remove_foreground_mobjects(mobject)

    def bring_to_front(self, *mobjects):
        self.add(*mobjects)
        return self

    def bring_to_back(self, *mobjects):
        self.remove(*mobjects)
        self.mobjects = list(mobjects) + self.mobjects
        return self

    def clear(self):
        self.mobjects = []
        self.foreground_mobjects = []
        return self

    def get_mobjects(self):
        return list(self.mobjects)

    def get_mobject_copies(self):
        return [m.copy() for m in self.mobjects]

    def get_moving_mobjects(self, *animations):
        # Go through mobjects from start to end, and
        # as soon as there&#39;s one that needs updating of
        # some kind per frame, return the list from that
        # point forward.
        animation_mobjects = [anim.mobject for anim in animations]
        mobjects = self.get_mobject_family_members()
        for i, mob in enumerate(mobjects):
            update_possibilities = [
                mob in animation_mobjects,
                len(mob.get_family_updaters()) &gt; 0,
                mob in self.foreground_mobjects
            ]
            if any(update_possibilities):
                return mobjects[i:]
        return []

    def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
        if self.skip_animations and not override_skip_animations:
            times = [run_time]
        else:
            step = 1 / self.camera.frame_rate
            times = np.arange(0, run_time, step)
        time_progression = ProgressDisplay(
            times, total=n_iterations,
            leave=self.leave_progress_bars,
            ascii=False if platform.system() != &#39;Windows&#39; else True
        )
        return time_progression

    def get_run_time(self, animations):
        return np.max([animation.run_time for animation in animations])

    def get_animation_time_progression(self, animations):
        run_time = self.get_run_time(animations)
        time_progression = self.get_time_progression(run_time)
        time_progression.set_description(&#34;&#34;.join([
            &#34;Animation {}: &#34;.format(self.num_plays),
            str(animations[0]),
            (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
        ]))
        return time_progression

    def compile_play_args_to_animation_list(self, *args, **kwargs):
        &#34;&#34;&#34;
        Each arg can either be an animation, or a mobject method
        followed by that methods arguments (and potentially follow
        by a dict of kwargs for that method).
        This animation list is built by going through the args list,
        and each animation is simply added, but when a mobject method
        s hit, a MoveToTarget animation is built using the args that
        follow up until either another animation is hit, another method
        is hit, or the args list runs out.
        &#34;&#34;&#34;
        animations = []
        state = {
            &#34;curr_method&#34;: None,
            &#34;last_method&#34;: None,
            &#34;method_args&#34;: [],
        }

        def compile_method(state):
            if state[&#34;curr_method&#34;] is None:
                return
            mobject = state[&#34;curr_method&#34;].__self__
            if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
                animations.pop()
                # method should already have target then.
            else:
                mobject.generate_target()
            #
            if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
                method_kwargs = state[&#34;method_args&#34;].pop()
            else:
                method_kwargs = {}
            state[&#34;curr_method&#34;].__func__(
                mobject.target,
                *state[&#34;method_args&#34;],
                **method_kwargs
            )
            animations.append(MoveToTarget(mobject))
            state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
            state[&#34;curr_method&#34;] = None
            state[&#34;method_args&#34;] = []

        for arg in args:
            if isinstance(arg, Animation):
                compile_method(state)
                animations.append(arg)
            elif inspect.ismethod(arg):
                compile_method(state)
                state[&#34;curr_method&#34;] = arg
            elif state[&#34;curr_method&#34;] is not None:
                state[&#34;method_args&#34;].append(arg)
            elif isinstance(arg, Mobject):
                raise Exception(&#34;&#34;&#34;
                    I think you may have invoked a method
                    you meant to pass in as a Scene.play argument
                &#34;&#34;&#34;)
            else:
                raise Exception(&#34;Invalid play arguments&#34;)
        compile_method(state)

        for animation in animations:
            # This is where kwargs to play like run_time and rate_func
            # get applied to all animations
            animation.update_config(**kwargs)

        return animations

    def update_skipping_status(self):
        if self.start_at_animation_number:
            if self.num_plays == self.start_at_animation_number:
                self.skip_animations = False
        if self.end_at_animation_number:
            if self.num_plays &gt;= self.end_at_animation_number:
                self.skip_animations = True
                raise EndSceneEarlyException()

    def handle_play_like_call(func):
        def wrapper(self, *args, **kwargs):
            self.update_skipping_status()
            allow_write = not self.skip_animations
            self.file_writer.begin_animation(allow_write)
            func(self, *args, **kwargs)
            self.file_writer.end_animation(allow_write)
            self.num_plays += 1
        return wrapper

    def begin_animations(self, animations):
        curr_mobjects = self.get_mobject_family_members()
        for animation in animations:
            # Begin animation
            animation.begin()
            # Anything animated that&#39;s not already in the
            # scene gets added to the scene
            mob = animation.mobject
            if mob not in curr_mobjects:
                self.add(mob)
                curr_mobjects += mob.get_family()

    def progress_through_animations(self, animations):
        # Paint all non-moving objects onto the screen, so they don&#39;t
        # have to be rendered every frame
        moving_mobjects = self.get_moving_mobjects(*animations)
        self.update_frame(excluded_mobjects=moving_mobjects)
        static_image = self.get_frame()
        last_t = 0
        for t in self.get_animation_time_progression(animations):
            dt = t - last_t
            last_t = t
            for animation in animations:
                animation.update_mobjects(dt)
                alpha = t / animation.run_time
                animation.interpolate(alpha)
            self.update_mobjects(dt)
            self.update_frame(moving_mobjects, static_image)
            self.add_frames(self.get_frame())

    def finish_animations(self, animations):
        for animation in animations:
            animation.finish()
            animation.clean_up_from_scene(self)
        self.mobjects_from_last_animation = [
            anim.mobject for anim in animations
        ]
        if self.skip_animations:
            # TODO, run this call in for each animation?
            self.update_mobjects(self.get_run_time(animations))
        else:
            self.update_mobjects(0)

    @handle_play_like_call
    def play(self, *args, **kwargs):
        if len(args) == 0:
            warnings.warn(&#34;Called Scene.play with no animations&#34;)
            return
        animations = self.compile_play_args_to_animation_list(
            *args, **kwargs
        )
        self.begin_animations(animations)
        self.progress_through_animations(animations)
        self.finish_animations(animations)

    def idle_stream(self):
        self.file_writer.idle_stream()

    def clean_up_animations(self, *animations):
        for animation in animations:
            animation.clean_up_from_scene(self)
        return self

    def get_mobjects_from_last_animation(self):
        if hasattr(self, &#34;mobjects_from_last_animation&#34;):
            return self.mobjects_from_last_animation
        return []

    def get_wait_time_progression(self, duration, stop_condition):
        if stop_condition is not None:
            time_progression = self.get_time_progression(
                duration,
                n_iterations=-1,  # So it doesn&#39;t show % progress
                override_skip_animations=True
            )
            time_progression.set_description(
                &#34;Waiting for {}&#34;.format(stop_condition.__name__)
            )
        else:
            time_progression = self.get_time_progression(duration)
            time_progression.set_description(
                &#34;Waiting {}&#34;.format(self.num_plays)
            )
        return time_progression

    @handle_play_like_call
    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):
        self.update_mobjects(dt=0)  # Any problems with this?
        if self.should_update_mobjects():
            time_progression = self.get_wait_time_progression(duration, stop_condition)
            # TODO, be smart about setting a static image
            # the same way Scene.play does
            last_t = 0
            for t in time_progression:
                dt = t - last_t
                last_t = t
                self.update_mobjects(dt)
                self.update_frame()
                self.add_frames(self.get_frame())
                if stop_condition is not None and stop_condition():
                    time_progression.close()
                    break
        elif self.skip_animations:
            # Do nothing
            return self
        else:
            self.update_frame()
            dt = 1 / self.camera.frame_rate
            n_frames = int(duration / dt)
            frame = self.get_frame()
            self.add_frames(*[frame] * n_frames)
        return self

    def wait_until(self, stop_condition, max_time=60):
        self.wait(max_time, stop_condition=stop_condition)

    def force_skipping(self):
        self.original_skipping_status = self.skip_animations
        self.skip_animations = True
        return self

    def revert_to_original_skipping_status(self):
        if hasattr(self, &#34;original_skipping_status&#34;):
            self.skip_animations = self.original_skipping_status
        return self

    def add_frames(self, *frames):
        dt = 1 / self.camera.frame_rate
        self.increment_time(len(frames) * dt)
        if self.skip_animations:
            return
        for frame in frames:
            self.file_writer.write_frame(frame)

    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
        if self.skip_animations:
            return
        time = self.get_time() + time_offset
        self.file_writer.add_sound(sound_file, time, gain, **kwargs)

    def show_frame(self):
        self.update_frame(ignore_skipping=True)
        self.get_image().show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="manimlib.container.container.Container" href="../container/container.html#manimlib.container.container.Container">Container</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="manimlib.for_3b1b_videos.common_scenes.Banner" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.Banner">Banner</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.ExternallyAnimatedScene" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.ExternallyAnimatedScene">ExternallyAnimatedScene</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.OpeningQuote" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.OpeningQuote">OpeningQuote</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.PatreonThanks" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.PatreonThanks">PatreonThanks</a></li>
<li><a title="manimlib.for_3b1b_videos.common_scenes.TODOStub" href="../for_3b1b_videos/common_scenes.html#manimlib.for_3b1b_videos.common_scenes.TODOStub">TODOStub</a></li>
<li><a title="manimlib.for_3b1b_videos.pi_creature_scene.PiCreatureScene" href="../for_3b1b_videos/pi_creature_scene.html#manimlib.for_3b1b_videos.pi_creature_scene.PiCreatureScene">PiCreatureScene</a></li>
<li><a title="manimlib.once_useful_constructs.arithmetic.RearrangeEquation" href="../once_useful_constructs/arithmetic.html#manimlib.once_useful_constructs.arithmetic.RearrangeEquation">RearrangeEquation</a></li>
<li><a title="manimlib.once_useful_constructs.combinatorics.CountingScene" href="../once_useful_constructs/combinatorics.html#manimlib.once_useful_constructs.combinatorics.CountingScene">CountingScene</a></li>
<li><a title="manimlib.once_useful_constructs.complex_transformation_scene.ComplexTransformationScene" href="../once_useful_constructs/complex_transformation_scene.html#manimlib.once_useful_constructs.complex_transformation_scene.ComplexTransformationScene">ComplexTransformationScene</a></li>
<li><a title="manimlib.once_useful_constructs.counting.CountingScene" href="../once_useful_constructs/counting.html#manimlib.once_useful_constructs.counting.CountingScene">CountingScene</a></li>
<li><a title="manimlib.once_useful_constructs.graph_theory.DiscreteGraphScene" href="../once_useful_constructs/graph_theory.html#manimlib.once_useful_constructs.graph_theory.DiscreteGraphScene">DiscreteGraphScene</a></li>
<li><a title="manimlib.once_useful_constructs.matrix_multiplication.NumericalMatrixMultiplication" href="../once_useful_constructs/matrix_multiplication.html#manimlib.once_useful_constructs.matrix_multiplication.NumericalMatrixMultiplication">NumericalMatrixMultiplication</a></li>
<li><a title="manimlib.scene.graph_scene.GraphScene" href="graph_scene.html#manimlib.scene.graph_scene.GraphScene">GraphScene</a></li>
<li><a title="manimlib.scene.moving_camera_scene.MovingCameraScene" href="moving_camera_scene.html#manimlib.scene.moving_camera_scene.MovingCameraScene">MovingCameraScene</a></li>
<li><a title="manimlib.scene.reconfigurable_scene.ReconfigurableScene" href="reconfigurable_scene.html#manimlib.scene.reconfigurable_scene.ReconfigurableScene">ReconfigurableScene</a></li>
<li><a title="manimlib.scene.sample_space_scene.SampleSpaceScene" href="sample_space_scene.html#manimlib.scene.sample_space_scene.SampleSpaceScene">SampleSpaceScene</a></li>
<li><a title="manimlib.scene.scene_from_video.SceneFromVideo" href="scene_from_video.html#manimlib.scene.scene_from_video.SceneFromVideo">SceneFromVideo</a></li>
<li><a title="manimlib.scene.three_d_scene.ThreeDScene" href="three_d_scene.html#manimlib.scene.three_d_scene.ThreeDScene">ThreeDScene</a></li>
<li><a title="manimlib.scene.vector_space_scene.VectorScene" href="vector_space_scene.html#manimlib.scene.vector_space_scene.VectorScene">VectorScene</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="manimlib.scene.scene.Scene.CONFIG"><code class="name">var <span class="ident">CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="manimlib.scene.scene.Scene.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"><p>Mobjects will be displayed, from background to
foreground in the order with which they are added.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, *mobjects):
    &#34;&#34;&#34;
    Mobjects will be displayed, from background to
    foreground in the order with which they are added.
    &#34;&#34;&#34;
    mobjects = [*mobjects, *self.foreground_mobjects]
    self.restructure_mobjects(to_remove=mobjects)
    self.mobjects += mobjects
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_foreground_mobject"><code class="name flex">
<span>def <span class="ident">add_foreground_mobject</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foreground_mobject(self, mobject):
    return self.add_foreground_mobjects(mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_foreground_mobjects"><code class="name flex">
<span>def <span class="ident">add_foreground_mobjects</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_foreground_mobjects(self, *mobjects):
    self.foreground_mobjects = list_update(
        self.foreground_mobjects,
        mobjects
    )
    self.add(*mobjects)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_frames"><code class="name flex">
<span>def <span class="ident">add_frames</span></span>(<span>self, *frames)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_frames(self, *frames):
    dt = 1 / self.camera.frame_rate
    self.increment_time(len(frames) * dt)
    if self.skip_animations:
        return
    for frame in frames:
        self.file_writer.write_frame(frame)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_mobjects_among"><code class="name flex">
<span>def <span class="ident">add_mobjects_among</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<div class="desc"><p>This is meant mostly for quick prototyping,
e.g. to add all mobjects defined up to a point,
call self.add_mobjects_among(locals().values())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mobjects_among(self, values):
    &#34;&#34;&#34;
    This is meant mostly for quick prototyping,
    e.g. to add all mobjects defined up to a point,
    call self.add_mobjects_among(locals().values())
    &#34;&#34;&#34;
    self.add(*filter(
        lambda m: isinstance(m, Mobject),
        values
    ))
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.add_sound"><code class="name flex">
<span>def <span class="ident">add_sound</span></span>(<span>self, sound_file, time_offset=0, gain=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):
    if self.skip_animations:
        return
    time = self.get_time() + time_offset
    self.file_writer.add_sound(sound_file, time, gain, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.begin_animations"><code class="name flex">
<span>def <span class="ident">begin_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_animations(self, animations):
    curr_mobjects = self.get_mobject_family_members()
    for animation in animations:
        # Begin animation
        animation.begin()
        # Anything animated that&#39;s not already in the
        # scene gets added to the scene
        mob = animation.mobject
        if mob not in curr_mobjects:
            self.add(mob)
            curr_mobjects += mob.get_family()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.bring_to_back"><code class="name flex">
<span>def <span class="ident">bring_to_back</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bring_to_back(self, *mobjects):
    self.remove(*mobjects)
    self.mobjects = list(mobjects) + self.mobjects
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.bring_to_front"><code class="name flex">
<span>def <span class="ident">bring_to_front</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bring_to_front(self, *mobjects):
    self.add(*mobjects)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.capture_mobjects_in_camera"><code class="name flex">
<span>def <span class="ident">capture_mobjects_in_camera</span></span>(<span>self, mobjects, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_mobjects_in_camera(self, mobjects, **kwargs):
    self.camera.capture_mobjects(mobjects, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.clean_up_animations"><code class="name flex">
<span>def <span class="ident">clean_up_animations</span></span>(<span>self, *animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up_animations(self, *animations):
    for animation in animations:
        animation.clean_up_from_scene(self)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.mobjects = []
    self.foreground_mobjects = []
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.compile_play_args_to_animation_list"><code class="name flex">
<span>def <span class="ident">compile_play_args_to_animation_list</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Each arg can either be an animation, or a mobject method
followed by that methods arguments (and potentially follow
by a dict of kwargs for that method).
This animation list is built by going through the args list,
and each animation is simply added, but when a mobject method
s hit, a MoveToTarget animation is built using the args that
follow up until either another animation is hit, another method
is hit, or the args list runs out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_play_args_to_animation_list(self, *args, **kwargs):
    &#34;&#34;&#34;
    Each arg can either be an animation, or a mobject method
    followed by that methods arguments (and potentially follow
    by a dict of kwargs for that method).
    This animation list is built by going through the args list,
    and each animation is simply added, but when a mobject method
    s hit, a MoveToTarget animation is built using the args that
    follow up until either another animation is hit, another method
    is hit, or the args list runs out.
    &#34;&#34;&#34;
    animations = []
    state = {
        &#34;curr_method&#34;: None,
        &#34;last_method&#34;: None,
        &#34;method_args&#34;: [],
    }

    def compile_method(state):
        if state[&#34;curr_method&#34;] is None:
            return
        mobject = state[&#34;curr_method&#34;].__self__
        if state[&#34;last_method&#34;] and state[&#34;last_method&#34;].__self__ is mobject:
            animations.pop()
            # method should already have target then.
        else:
            mobject.generate_target()
        #
        if len(state[&#34;method_args&#34;]) &gt; 0 and isinstance(state[&#34;method_args&#34;][-1], dict):
            method_kwargs = state[&#34;method_args&#34;].pop()
        else:
            method_kwargs = {}
        state[&#34;curr_method&#34;].__func__(
            mobject.target,
            *state[&#34;method_args&#34;],
            **method_kwargs
        )
        animations.append(MoveToTarget(mobject))
        state[&#34;last_method&#34;] = state[&#34;curr_method&#34;]
        state[&#34;curr_method&#34;] = None
        state[&#34;method_args&#34;] = []

    for arg in args:
        if isinstance(arg, Animation):
            compile_method(state)
            animations.append(arg)
        elif inspect.ismethod(arg):
            compile_method(state)
            state[&#34;curr_method&#34;] = arg
        elif state[&#34;curr_method&#34;] is not None:
            state[&#34;method_args&#34;].append(arg)
        elif isinstance(arg, Mobject):
            raise Exception(&#34;&#34;&#34;
                I think you may have invoked a method
                you meant to pass in as a Scene.play argument
            &#34;&#34;&#34;)
        else:
            raise Exception(&#34;Invalid play arguments&#34;)
    compile_method(state)

    for animation in animations:
        # This is where kwargs to play like run_time and rate_func
        # get applied to all animations
        animation.update_config(**kwargs)

    return animations</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.construct"><code class="name flex">
<span>def <span class="ident">construct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct(self):
    pass  # To be implemented in subclasses</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.finish_animations"><code class="name flex">
<span>def <span class="ident">finish_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_animations(self, animations):
    for animation in animations:
        animation.finish()
        animation.clean_up_from_scene(self)
    self.mobjects_from_last_animation = [
        anim.mobject for anim in animations
    ]
    if self.skip_animations:
        # TODO, run this call in for each animation?
        self.update_mobjects(self.get_run_time(animations))
    else:
        self.update_mobjects(0)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.force_skipping"><code class="name flex">
<span>def <span class="ident">force_skipping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_skipping(self):
    self.original_skipping_status = self.skip_animations
    self.skip_animations = True
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.freeze_background"><code class="name flex">
<span>def <span class="ident">freeze_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze_background(self):
    self.update_frame()
    self.set_camera(Camera(self.get_frame()))
    self.clear()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_animation_time_progression"><code class="name flex">
<span>def <span class="ident">get_animation_time_progression</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_animation_time_progression(self, animations):
    run_time = self.get_run_time(animations)
    time_progression = self.get_time_progression(run_time)
    time_progression.set_description(&#34;&#34;.join([
        &#34;Animation {}: &#34;.format(self.num_plays),
        str(animations[0]),
        (&#34;, etc.&#34; if len(animations) &gt; 1 else &#34;&#34;),
    ]))
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_attrs"><code class="name flex">
<span>def <span class="ident">get_attrs</span></span>(<span>self, *keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attrs(self, *keys):
    return [getattr(self, key) for key in keys]</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(self):
    return np.array(self.camera.get_pixel_array())</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image(self):
    return self.camera.get_image()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobject_copies"><code class="name flex">
<span>def <span class="ident">get_mobject_copies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobject_copies(self):
    return [m.copy() for m in self.mobjects]</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobject_family_members"><code class="name flex">
<span>def <span class="ident">get_mobject_family_members</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobject_family_members(self):
    return self.camera.extract_mobject_family_members(self.mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobjects"><code class="name flex">
<span>def <span class="ident">get_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects(self):
    return list(self.mobjects)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_mobjects_from_last_animation"><code class="name flex">
<span>def <span class="ident">get_mobjects_from_last_animation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mobjects_from_last_animation(self):
    if hasattr(self, &#34;mobjects_from_last_animation&#34;):
        return self.mobjects_from_last_animation
    return []</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_moving_mobjects"><code class="name flex">
<span>def <span class="ident">get_moving_mobjects</span></span>(<span>self, *animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_moving_mobjects(self, *animations):
    # Go through mobjects from start to end, and
    # as soon as there&#39;s one that needs updating of
    # some kind per frame, return the list from that
    # point forward.
    animation_mobjects = [anim.mobject for anim in animations]
    mobjects = self.get_mobject_family_members()
    for i, mob in enumerate(mobjects):
        update_possibilities = [
            mob in animation_mobjects,
            len(mob.get_family_updaters()) &gt; 0,
            mob in self.foreground_mobjects
        ]
        if any(update_possibilities):
            return mobjects[i:]
    return []</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_restructured_mobject_list"><code class="name flex">
<span>def <span class="ident">get_restructured_mobject_list</span></span>(<span>self, mobjects, to_remove)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_restructured_mobject_list(self, mobjects, to_remove):
    new_mobjects = []

    def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
        for mob in list_to_examine:
            if mob in set_to_remove:
                continue
            intersect = set_to_remove.intersection(mob.get_family())
            if intersect:
                add_safe_mobjects_from_list(mob.submobjects, intersect)
            else:
                new_mobjects.append(mob)
    add_safe_mobjects_from_list(mobjects, set(to_remove))
    return new_mobjects</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_run_time"><code class="name flex">
<span>def <span class="ident">get_run_time</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_run_time(self, animations):
    return np.max([animation.run_time for animation in animations])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self):
    return self.time</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_time_progression"><code class="name flex">
<span>def <span class="ident">get_time_progression</span></span>(<span>self, run_time, n_iterations=None, override_skip_animations=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_progression(self, run_time, n_iterations=None, override_skip_animations=False):
    if self.skip_animations and not override_skip_animations:
        times = [run_time]
    else:
        step = 1 / self.camera.frame_rate
        times = np.arange(0, run_time, step)
    time_progression = ProgressDisplay(
        times, total=n_iterations,
        leave=self.leave_progress_bars,
        ascii=False if platform.system() != &#39;Windows&#39; else True
    )
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_top_level_mobjects"><code class="name flex">
<span>def <span class="ident">get_top_level_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top_level_mobjects(self):
    # Return only those which are not in the family
    # of another mobject from the scene
    mobjects = self.get_mobjects()
    families = [m.get_family() for m in mobjects]

    def is_top_level(mobject):
        num_families = sum([
            (mobject in family)
            for family in families
        ])
        return num_families == 1
    return list(filter(is_top_level, mobjects))</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.get_wait_time_progression"><code class="name flex">
<span>def <span class="ident">get_wait_time_progression</span></span>(<span>self, duration, stop_condition)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wait_time_progression(self, duration, stop_condition):
    if stop_condition is not None:
        time_progression = self.get_time_progression(
            duration,
            n_iterations=-1,  # So it doesn&#39;t show % progress
            override_skip_animations=True
        )
        time_progression.set_description(
            &#34;Waiting for {}&#34;.format(stop_condition.__name__)
        )
    else:
        time_progression = self.get_time_progression(duration)
        time_progression.set_description(
            &#34;Waiting {}&#34;.format(self.num_plays)
        )
    return time_progression</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.handle_play_like_call"><code class="name flex">
<span>def <span class="ident">handle_play_like_call</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_play_like_call(func):
    def wrapper(self, *args, **kwargs):
        self.update_skipping_status()
        allow_write = not self.skip_animations
        self.file_writer.begin_animation(allow_write)
        func(self, *args, **kwargs)
        self.file_writer.end_animation(allow_write)
        self.num_plays += 1
    return wrapper</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.idle_stream"><code class="name flex">
<span>def <span class="ident">idle_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_stream(self):
    self.file_writer.idle_stream()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.increment_time"><code class="name flex">
<span>def <span class="ident">increment_time</span></span>(<span>self, d_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_time(self, d_time):
    self.time += d_time</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, *args, **kwargs):
    self.update_skipping_status()
    allow_write = not self.skip_animations
    self.file_writer.begin_animation(allow_write)
    func(self, *args, **kwargs)
    self.file_writer.end_animation(allow_write)
    self.num_plays += 1</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.print_end_message"><code class="name flex">
<span>def <span class="ident">print_end_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_end_message(self):
    print(&#34;Played {} animations&#34;.format(self.num_plays))</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.progress_through_animations"><code class="name flex">
<span>def <span class="ident">progress_through_animations</span></span>(<span>self, animations)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_through_animations(self, animations):
    # Paint all non-moving objects onto the screen, so they don&#39;t
    # have to be rendered every frame
    moving_mobjects = self.get_moving_mobjects(*animations)
    self.update_frame(excluded_mobjects=moving_mobjects)
    static_image = self.get_frame()
    last_t = 0
    for t in self.get_animation_time_progression(animations):
        dt = t - last_t
        last_t = t
        for animation in animations:
            animation.update_mobjects(dt)
            alpha = t / animation.run_time
            animation.interpolate(alpha)
        self.update_mobjects(dt)
        self.update_frame(moving_mobjects, static_image)
        self.add_frames(self.get_frame())</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, *mobjects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, *mobjects):
    for list_name in &#34;mobjects&#34;, &#34;foreground_mobjects&#34;:
        self.restructure_mobjects(mobjects, list_name, False)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove_foreground_mobject"><code class="name flex">
<span>def <span class="ident">remove_foreground_mobject</span></span>(<span>self, mobject)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_foreground_mobject(self, mobject):
    return self.remove_foreground_mobjects(mobject)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.remove_foreground_mobjects"><code class="name flex">
<span>def <span class="ident">remove_foreground_mobjects</span></span>(<span>self, *to_remove)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_foreground_mobjects(self, *to_remove):
    self.restructure_mobjects(to_remove, &#34;foreground_mobjects&#34;)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.reset_camera"><code class="name flex">
<span>def <span class="ident">reset_camera</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_camera(self):
    self.camera.reset()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.restructure_mobjects"><code class="name flex">
<span>def <span class="ident">restructure_mobjects</span></span>(<span>self, to_remove, mobject_list_name='mobjects', extract_families=True)</span>
</code></dt>
<dd>
<div class="desc"><p>In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
will be editing to contain other submobjects, but not m1, e.g. it will now
insert m2 and m3 to where the group once was.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restructure_mobjects(self, to_remove,
                         mobject_list_name=&#34;mobjects&#34;,
                         extract_families=True):
    &#34;&#34;&#34;
    In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
    of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
    will be editing to contain other submobjects, but not m1, e.g. it will now
    insert m2 and m3 to where the group once was.
    &#34;&#34;&#34;
    if extract_families:
        to_remove = self.camera.extract_mobject_family_members(to_remove)
    _list = getattr(self, mobject_list_name)
    new_list = self.get_restructured_mobject_list(_list, to_remove)
    setattr(self, mobject_list_name, new_list)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.revert_to_original_skipping_status"><code class="name flex">
<span>def <span class="ident">revert_to_original_skipping_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revert_to_original_skipping_status(self):
    if hasattr(self, &#34;original_skipping_status&#34;):
        self.skip_animations = self.original_skipping_status
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera"><code class="name flex">
<span>def <span class="ident">set_camera</span></span>(<span>self, camera)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera(self, camera):
    self.camera = camera</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera_background"><code class="name flex">
<span>def <span class="ident">set_camera_background</span></span>(<span>self, background)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera_background(self, background):
    self.camera.set_background(background)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_camera_pixel_array"><code class="name flex">
<span>def <span class="ident">set_camera_pixel_array</span></span>(<span>self, pixel_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_camera_pixel_array(self, pixel_array):
    self.camera.set_pixel_array(pixel_array)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.set_variables_as_attrs"><code class="name flex">
<span>def <span class="ident">set_variables_as_attrs</span></span>(<span>self, *objects, **newly_named_objects)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is slightly hacky, making it a little easier
for certain methods (typically subroutines of construct)
to share local variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variables_as_attrs(self, *objects, **newly_named_objects):
    &#34;&#34;&#34;
    This method is slightly hacky, making it a little easier
    for certain methods (typically subroutines of construct)
    to share local variables.
    &#34;&#34;&#34;
    caller_locals = inspect.currentframe().f_back.f_locals
    for key, value in list(caller_locals.items()):
        for o in objects:
            if value is o:
                setattr(self, key, value)
    for key, value in list(newly_named_objects.items()):
        setattr(self, key, value)
    return self</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is meant to be implement by any scenes which
are comonly subclassed, and have some common setup
involved before the construct method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    &#34;&#34;&#34;
    This is meant to be implement by any scenes which
    are comonly subclassed, and have some common setup
    involved before the construct method is called.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.should_update_mobjects"><code class="name flex">
<span>def <span class="ident">should_update_mobjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_update_mobjects(self):
    return self.always_update_mobjects or any([
        mob.has_time_based_updater()
        for mob in self.get_mobject_family_members()
    ])</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.show_frame"><code class="name flex">
<span>def <span class="ident">show_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_frame(self):
    self.update_frame(ignore_skipping=True)
    self.get_image().show()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.tear_down"><code class="name flex">
<span>def <span class="ident">tear_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tear_down(self):
    pass</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_frame"><code class="name flex">
<span>def <span class="ident">update_frame</span></span>(<span>self, mobjects=None, background=None, include_submobjects=True, ignore_skipping=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_frame(
        self,
        mobjects=None,
        background=None,
        include_submobjects=True,
        ignore_skipping=True,
        **kwargs):
    if self.skip_animations and not ignore_skipping:
        return
    if mobjects is None:
        mobjects = list_update(
            self.mobjects,
            self.foreground_mobjects,
        )
    if background is not None:
        self.set_camera_pixel_array(background)
    else:
        self.reset_camera()

    kwargs[&#34;include_submobjects&#34;] = include_submobjects
    self.capture_mobjects_in_camera(mobjects, **kwargs)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_mobjects"><code class="name flex">
<span>def <span class="ident">update_mobjects</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mobjects(self, dt):
    for mobject in self.mobjects:
        mobject.update(dt)</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.update_skipping_status"><code class="name flex">
<span>def <span class="ident">update_skipping_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_skipping_status(self):
    if self.start_at_animation_number:
        if self.num_plays == self.start_at_animation_number:
            self.skip_animations = False
    if self.end_at_animation_number:
        if self.num_plays &gt;= self.end_at_animation_number:
            self.skip_animations = True
            raise EndSceneEarlyException()</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, *args, **kwargs):
    self.update_skipping_status()
    allow_write = not self.skip_animations
    self.file_writer.begin_animation(allow_write)
    func(self, *args, **kwargs)
    self.file_writer.end_animation(allow_write)
    self.num_plays += 1</code></pre>
</details>
</dd>
<dt id="manimlib.scene.scene.Scene.wait_until"><code class="name flex">
<span>def <span class="ident">wait_until</span></span>(<span>self, stop_condition, max_time=60)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until(self, stop_condition, max_time=60):
    self.wait(max_time, stop_condition=stop_condition)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="manimlib.scene" href="index.html">manimlib.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="manimlib.scene.scene.EndSceneEarlyException" href="#manimlib.scene.scene.EndSceneEarlyException">EndSceneEarlyException</a></code></h4>
</li>
<li>
<h4><code><a title="manimlib.scene.scene.Scene" href="#manimlib.scene.scene.Scene">Scene</a></code></h4>
<ul class="">
<li><code><a title="manimlib.scene.scene.Scene.CONFIG" href="#manimlib.scene.scene.Scene.CONFIG">CONFIG</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add" href="#manimlib.scene.scene.Scene.add">add</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobject" href="#manimlib.scene.scene.Scene.add_foreground_mobject">add_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_foreground_mobjects" href="#manimlib.scene.scene.Scene.add_foreground_mobjects">add_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_frames" href="#manimlib.scene.scene.Scene.add_frames">add_frames</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_mobjects_among" href="#manimlib.scene.scene.Scene.add_mobjects_among">add_mobjects_among</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.add_sound" href="#manimlib.scene.scene.Scene.add_sound">add_sound</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.begin_animations" href="#manimlib.scene.scene.Scene.begin_animations">begin_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_back" href="#manimlib.scene.scene.Scene.bring_to_back">bring_to_back</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.bring_to_front" href="#manimlib.scene.scene.Scene.bring_to_front">bring_to_front</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.capture_mobjects_in_camera" href="#manimlib.scene.scene.Scene.capture_mobjects_in_camera">capture_mobjects_in_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clean_up_animations" href="#manimlib.scene.scene.Scene.clean_up_animations">clean_up_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.clear" href="#manimlib.scene.scene.Scene.clear">clear</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.compile_play_args_to_animation_list" href="#manimlib.scene.scene.Scene.compile_play_args_to_animation_list">compile_play_args_to_animation_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.construct" href="#manimlib.scene.scene.Scene.construct">construct</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.finish_animations" href="#manimlib.scene.scene.Scene.finish_animations">finish_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.force_skipping" href="#manimlib.scene.scene.Scene.force_skipping">force_skipping</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.freeze_background" href="#manimlib.scene.scene.Scene.freeze_background">freeze_background</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_animation_time_progression" href="#manimlib.scene.scene.Scene.get_animation_time_progression">get_animation_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_attrs" href="#manimlib.scene.scene.Scene.get_attrs">get_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_frame" href="#manimlib.scene.scene.Scene.get_frame">get_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_image" href="#manimlib.scene.scene.Scene.get_image">get_image</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_copies" href="#manimlib.scene.scene.Scene.get_mobject_copies">get_mobject_copies</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobject_family_members" href="#manimlib.scene.scene.Scene.get_mobject_family_members">get_mobject_family_members</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects" href="#manimlib.scene.scene.Scene.get_mobjects">get_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_mobjects_from_last_animation" href="#manimlib.scene.scene.Scene.get_mobjects_from_last_animation">get_mobjects_from_last_animation</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_moving_mobjects" href="#manimlib.scene.scene.Scene.get_moving_mobjects">get_moving_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_restructured_mobject_list" href="#manimlib.scene.scene.Scene.get_restructured_mobject_list">get_restructured_mobject_list</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_run_time" href="#manimlib.scene.scene.Scene.get_run_time">get_run_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time" href="#manimlib.scene.scene.Scene.get_time">get_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_time_progression" href="#manimlib.scene.scene.Scene.get_time_progression">get_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_top_level_mobjects" href="#manimlib.scene.scene.Scene.get_top_level_mobjects">get_top_level_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.get_wait_time_progression" href="#manimlib.scene.scene.Scene.get_wait_time_progression">get_wait_time_progression</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.handle_play_like_call" href="#manimlib.scene.scene.Scene.handle_play_like_call">handle_play_like_call</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.idle_stream" href="#manimlib.scene.scene.Scene.idle_stream">idle_stream</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.increment_time" href="#manimlib.scene.scene.Scene.increment_time">increment_time</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.play" href="#manimlib.scene.scene.Scene.play">play</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.print_end_message" href="#manimlib.scene.scene.Scene.print_end_message">print_end_message</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.progress_through_animations" href="#manimlib.scene.scene.Scene.progress_through_animations">progress_through_animations</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove" href="#manimlib.scene.scene.Scene.remove">remove</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobject" href="#manimlib.scene.scene.Scene.remove_foreground_mobject">remove_foreground_mobject</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.remove_foreground_mobjects" href="#manimlib.scene.scene.Scene.remove_foreground_mobjects">remove_foreground_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.reset_camera" href="#manimlib.scene.scene.Scene.reset_camera">reset_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.restructure_mobjects" href="#manimlib.scene.scene.Scene.restructure_mobjects">restructure_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.revert_to_original_skipping_status" href="#manimlib.scene.scene.Scene.revert_to_original_skipping_status">revert_to_original_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera" href="#manimlib.scene.scene.Scene.set_camera">set_camera</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_background" href="#manimlib.scene.scene.Scene.set_camera_background">set_camera_background</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_camera_pixel_array" href="#manimlib.scene.scene.Scene.set_camera_pixel_array">set_camera_pixel_array</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.set_variables_as_attrs" href="#manimlib.scene.scene.Scene.set_variables_as_attrs">set_variables_as_attrs</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.setup" href="#manimlib.scene.scene.Scene.setup">setup</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.should_update_mobjects" href="#manimlib.scene.scene.Scene.should_update_mobjects">should_update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.show_frame" href="#manimlib.scene.scene.Scene.show_frame">show_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.tear_down" href="#manimlib.scene.scene.Scene.tear_down">tear_down</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_frame" href="#manimlib.scene.scene.Scene.update_frame">update_frame</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_mobjects" href="#manimlib.scene.scene.Scene.update_mobjects">update_mobjects</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.update_skipping_status" href="#manimlib.scene.scene.Scene.update_skipping_status">update_skipping_status</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.wait" href="#manimlib.scene.scene.Scene.wait">wait</a></code></li>
<li><code><a title="manimlib.scene.scene.Scene.wait_until" href="#manimlib.scene.scene.Scene.wait_until">wait_until</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>